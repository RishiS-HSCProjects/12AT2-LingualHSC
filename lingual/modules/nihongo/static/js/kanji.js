// PLEASE NOTE
// Some of the concept and structures were generated using AI.
// Specifically, smoothness logic and the Intersection Observer implementation were
// written with the help of ChatGPT. Refer to AI declaration.

document.addEventListener("DOMContentLoaded", () => {
    // Assign DOM elements to constants for faster access
	const page = document.getElementById("kanji-page");
	const grid = document.getElementById("kanji-grid");
	const blocks = Array.from(document.querySelectorAll(".kanji-block"));
	const panel = document.getElementById("kanji-info");
	const closeButton = document.getElementById("kanji-info-close");

	const infoChar = document.getElementById("kanji-info-char");
	const infoPrimary = document.getElementById("kanji-info-primary");
	const infoMeanings = document.getElementById("kanji-info-meanings");
	const infoOnyomi = document.getElementById("kanji-info-onyomi");
	const infoKunyomi = document.getElementById("kanji-info-kunyomi");

	/* Whenever a kanji block is clicked, its data is fetched and displayed in the info panel.
	   Since kanji data does not change often, we cache API data into nihongo/data/kanji/*.json
	   files on the server side. However, to retrieve server-side cached data, we would have
	   needed to make a new HTTP request to the server's API every time a kanji block is clicked.
	   While server HTTP requests are efficient, to further optimise performance, repetitive
	   requests create unnecessary overhead and result in slight latency, potentially impacting
	   users across the application (even the ones not using the kanji module). To mitigate
	   this, we implement a simple in-memory cache here on the client side to store fetched
	   kanji data during the user's session. This way, once a kanji's data is fetched from
	   the server, it can be quickly retrieved from the cache without additional HTTP requests.
	   
	   Since this logic is not exclusive to kanji storage and can be applied to other language
	   models, this logic should be moved into a shared utility file in the future. In the case
	   I decide to implement similar caching for vocabulary or grammar data, or implement other
	   modules later on, I will spend time to move this caching logic into a shared utility file.

	   Documented on 8 Feb 2026.
	*/
	const kanjiCache = new Map(); // In-memory cache to store fetched kanji data during the session

	if (!page || !grid || blocks.length === 0 || !panel) {
        console.error("Essential kanji elements are missing from the DOM.");
		return; // Essential elements are missing, so we exit early to avoid errors.
	}

	const setActive = (activeBlock) => {
		blocks.forEach((block) => block.classList.remove("is-active")); // Remove all other active states
		activeBlock.classList.add("is-active"); // Set the clicked block as active
	};

	const openPanel = () => {
		page.classList.add("panel-open"); // Add class to body to trigger CSS changes for panel visibility
		panel.setAttribute("aria-hidden", "false"); // Update ARIA attribute for accessibility
	};

	const closePanel = () => {
		page.classList.remove("panel-open"); // Remove class to hide the panel
		panel.setAttribute("aria-hidden", "true"); // Update ARIA attribute for accessibility
		blocks.forEach((block) => block.classList.remove("is-active")); // Remove all active states when closing the panel
	};

    /** Updates the information panel with data from the selected kanji block */
	const setLoadingPanel = (kanji) => {
		// Default loading state.
		infoChar.textContent = kanji;
		infoPrimary.textContent = "Data not available yet. Please try again in a moment.";
		infoMeanings.textContent = "";
		infoOnyomi.textContent = "";
		infoKunyomi.textContent = "";
	};

	/**
	 * Updates the information panel with data from the fetched kanji.
	 * Logic generated by Github Copilot. Refer to AI declaration.
	 */
	const updatePanelFromData = (kanji, data) => {
		const meanings = Array.isArray(data?.meanings)
			? data.meanings.map((m) => m.meaning).filter(Boolean) // Filter out any falsy values
			: []; // Default to empty array if meanings is not an array
		const primaryMeaning = Array.isArray(data?.meanings)
			? (data.meanings.find((m) => m.primary)?.meaning || "")
			: ""; // Default to empty string if meanings is not an array
		const onyomi = Array.isArray(data?.readings)
			? data.readings.filter((r) => r.type === "onyomi").map((r) => r.reading).filter(Boolean) // Filter out any falsy values
			: []; // Default to empty array if readings is not an array
		const kunyomi = Array.isArray(data?.readings)
			? data.readings.filter((r) => r.type === "kunyomi").map((r) => r.reading).filter(Boolean) // Filter out any falsy values
			: []; // Default to empty array if readings is not an array

		// Set info content
		infoChar.textContent = kanji;
		infoPrimary.textContent = primaryMeaning ? `Primary: ${primaryMeaning}` : "Primary: N/A";
		infoMeanings.textContent = meanings.length ? meanings.join(", ") : "No meanings listed.";
		infoOnyomi.textContent = onyomi.length ? onyomi.join(" ・ ") : "No on'yomi recorded.";
		infoKunyomi.textContent = kunyomi.length ? kunyomi.join(" ・ ") : "No kun'yomi recorded.";
	};

	/**
	 * Fetches kanji data from the server API.
	 */
	const fetchKanjiData = async (kanji) => {
		try {
			// Fetch kanji data from the server's API
			// Encode the kanji to ensure it's safe for use in a URL (just in case)
			const res = await fetch(`api/${encodeURIComponent(kanji)}`);
			if (!res.ok) { // Handle non-OK responses
				// Throw error to be caught below
				/* This allows us to handle fetch errors uniformly,
				   whether they are network errors or server errors. */
				throw new Error(`Failed to fetch kanji data: ${res.status}`);
			}
			return await res.json(); // Return the fetched kanji data
		} catch (error) { // Catch all errors
			console.error("Kanji fetch failed:", error); // Log any errors during fetch
			return { status: "loading" }; // Return loading status on error
		}
	};
	
	// Simple delay function to create a pause between API requests when "warming" the cache.
	// This helps to avoid overwhelming the server with too many requests in a short period,
	// which could lead to rate limiting or degraded performance.
	const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

	/**
	 * Warming cache refers to the process of pre-fetching and storing data in the
	 * cache before it is actually needed. In this context, it means fetching kanji
	 * data for all the kanji blocks on the page and storing it in the `kanjiCache` Map.
	 * This way, when a user clicks on a kanji block, the data is already available in
	 * the cache, resulting in faster response times and a smoother user experience.
	 * The function iterates through each kanji block, checks if its data is already
	 * cached, and if not, fetches the data and stores it in the cache. A delay is added
	 * between requests to prevent overwhelming the server.
	 */
	const warmCacheAll = async () => { // Declare async function
		for (const block of blocks) { // Loop through each kanji block
			const kanji = block.dataset.kanji || ""; // Get the kanji character from the block's data attribute, default to empty string if not present
			if (!kanji || kanjiCache.has(kanji)) continue; // Skip if kanji is invalid / already cached

			const result = await fetchKanjiData(kanji); // Fetch kanji data from the server API
			if (result.status === "ready" && result.data) { // If data is ready and valid, store it in the cache and mark the block as loaded
				kanjiCache.set(kanji, result.data); // Cache the fetched data for this kanji
				block.dataset.loaded = "true"; // Mark the block as loaded to prevent refetching
			}

			await delay(120); // Add delay to avoid rate limits. (Possibly helping out in the future.)
		}
	};

	blocks.forEach((block) => {
		block.tabIndex = 0; // Make each kanji block focusable for accessibility
		block.role = "button"; // Set role to button for screen readers to identify it as an interactive element
		// Add click event listener to each kanji block to handle selection and panel updates
		block.addEventListener("click", async () => {
			const kanji = block.dataset.kanji || "";
			setActive(block); // Set the clicked block as active
			openPanel(); // Open the information panel (if not already open)
			block.scrollIntoView({ // Smoothly scroll the selected block into view, centered in the viewport
				behavior: "smooth",
				block: "center",
				inline: "center"
			});

			if (!kanji) {
				setLoadingPanel(""); // Clear panel if kanji is invalid
				return;
			}

			const cached = kanjiCache.get(kanji); // Get cached data if available
			if (cached) {
				updatePanelFromData(kanji, cached); // Update panel from cached data
				return; // Exit early since data already available
			}

			setLoadingPanel(kanji); // Show loading state while fetching data
			const result = await fetchKanjiData(kanji);
			if (result.status === "ready" && result.data) {
				kanjiCache.set(kanji, result.data); // Cache the fetched data
				block.dataset.loaded = "true"; // Mark the block as loaded
				updatePanelFromData(kanji, result.data); // Update the panel with the fetched data
			}
		});
		block.addEventListener("keydown", (event) => {
			if (event.key === "Enter" || event.key === " ") { // Allow selection with Enter or Space keys for accessibility
				event.preventDefault(); // Prevent default behavior (like scrolling)
				block.click(); // Trigger the click event to open the panel and load data
			}
		});
	});

	if (closeButton) {
		closeButton.addEventListener("click", () => {
			closePanel(); // Close the information panel when the close button is clicked
		});
	}

	// Listen for errors during the cache warming process and log them to the console.
	warmCacheAll().catch((error) => {
		console.error("Kanji prefetch failed:", error);
	});

	document.addEventListener("keydown", (event) => {
		if (event.key === "Escape") {
			closePanel(); // Close the information panel when the Escape key is pressed
		}
	});

    // Intersection Observer to add "is-visible" class to kanji blocks as they enter the
    // viewport for animation effects. This implementation uses the Intersection Observer
    // API to efficiently detect when kanji blocks enter the viewport. When a block
    // becomes visible, it adds the "is-visible" class, which can trigger CSS animations
    // or transitions. The observer is configured with a root margin to start the animation
    // slightly before the block fully enters the view, creating a smoother user experience.
    // If the browser does not support Intersection Observer, all blocks are made visible
    // immediately as a fallback.
	if ("IntersectionObserver" in window) {
		const observer = new IntersectionObserver(
			(entries, entryObserver) => { // Loop through observed entries to check if they are intersecting (visible in the viewport)
				entries.forEach((entry) => {
					if (entry.isIntersecting) {
						entry.target.classList.add("is-visible"); // Add class to trigger visibility/animation
						entryObserver.unobserve(entry.target); // Stop observing this block since it's already visible.
					}
				});
			},
			{
				root: document.getElementById("kanji-list"), // Set the root to the scrollable container of the kanji blocks
				rootMargin: "60px", // Start the animation slightly before the block fully enters the view for a smoother effect
				threshold: 0.2 // Trigger when 20% of the block is visible in the viewport
			}
		);

		blocks.forEach((block) => observer.observe(block)); // Start observing each kanji block for visibility changes
	} else {
		blocks.forEach((block) => block.classList.add("is-visible")); // Fallback for browsers that do not support Intersection Observer: make all blocks visible immediately
	}
});
