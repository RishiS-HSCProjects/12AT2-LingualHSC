// PLEASE NOTE
// Some of the concept and structures were generated using AI.
// Specifically, smoothness logic and the Intersection Observer implementation were
// written with the help of ChatGPT. Refer to AI declaration.

document.addEventListener("DOMContentLoaded", () => {
    // Assign DOM elements to constants for faster access
	const page = document.getElementById("kanji-page");
	const grid = document.getElementById("kanji-grid");
	const blocks = Array.from(document.querySelectorAll(".kanji-block"));
	const panel = document.getElementById("kanji-info");
	const closeButton = document.getElementById("kanji-info-close");

	const infoChar = document.getElementById("kanji-info-char");
	const infoPrimary = document.getElementById("kanji-info-primary");
	const infoType = document.getElementById("kanji-info-type");
	const infoMeanings = document.getElementById("kanji-info-meanings");
	const infoOnyomi = document.getElementById("kanji-info-onyomi");
	const infoKunyomi = document.getElementById("kanji-info-kunyomi");

	/* Whenever a kanji block is clicked, its data is fetched and displayed in the info panel.
	   Since kanji data does not change often, we cache API data into nihongo/data/kanji/*.json
	   files on the server side. However, to retrieve server-side cached data, we would have
	   needed to make a new HTTP request to the server's API every time a kanji block is clicked.
	   While server HTTP requests are efficient, to further optimise performance, repetitive
	   requests create unnecessary overhead and result in slight latency, potentially impacting
	   users across the application (even the ones not using the kanji module). To mitigate
	   this, we implement a simple in-memory cache here on the client side to store fetched
	   kanji data during the user's session. This way, once a kanji's data is fetched from
	   the server, it can be quickly retrieved from the cache without additional HTTP requests.
	   
	   Since this logic is not exclusive to kanji storage and can be applied to other language
	   models, this logic should be moved into a shared utility file in the future. In the case
	   I decide to implement similar caching for vocabulary or grammar data, or implement other
	   modules later on, I will spend time to move this caching logic into a shared utility file.

	   Documented on 8 Feb 2026.
	*/
	const kanjiCache = new Map(); // In-memory cache to store fetched kanji data during the session

	if (!page || !grid || blocks.length === 0 || !panel) {
        console.error("Essential kanji elements are missing from the DOM.");
		return; // Essential elements are missing, so we exit early to avoid errors.
	}

	const setActive = (activeBlock) => {
		blocks.forEach((block) => block.classList.remove("is-active")); // Remove all other active states
		activeBlock.classList.add("is-active"); // Set the clicked block as active
	};

	const openPanel = () => {
		page.classList.add("panel-open"); // Add class to body to trigger CSS changes for panel visibility
		panel.setAttribute("aria-hidden", "false"); // Update ARIA attribute for accessibility
	};

	const closePanel = () => {
		page.classList.remove("panel-open"); // Remove class to hide the panel
		panel.setAttribute("aria-hidden", "true"); // Update ARIA attribute for accessibility
		blocks.forEach((block) => block.classList.remove("is-active")); // Remove all active states when closing the panel
	};

    /** Updates the information panel with data from the selected kanji block */
	const setLoadingPanel = (kanji) => {
		// Default loading state.
		infoChar.textContent = kanji;
		infoPrimary.textContent = "Data not available yet. Please try again in a moment.";
		infoType.hidden = true;
		const label = infoType.querySelector(".kanji-type-label");
		if (label) label.textContent = "";
		infoMeanings.textContent = "";
		infoOnyomi.textContent = "";
		infoKunyomi.textContent = "";
	};

	/**
	 * Updates the information panel with data from the fetched kanji.
	 * Logic generated by Github Copilot. Refer to AI declaration.
	 */
	const updatePanelFromData = (kanji, payload) => {
		const data = payload?.data || {};
		const type = payload?.type || null;
		const meanings = Array.isArray(data?.meanings)
			? data.meanings.map((m) => m.meaning).filter(Boolean) // Filter out any falsy values
			: []; // Default to empty array if meanings is not an array
		const primaryMeaning = Array.isArray(data?.meanings)
			? (data.meanings.find((m) => m.primary)?.meaning || "")
			: ""; // Default to empty string if meanings is not an array
		const onyomi = Array.isArray(data?.readings)
			? data.readings.filter((r) => r.type === "onyomi").map((r) => r.reading).filter(Boolean) // Filter out any falsy values
			: []; // Default to empty array if readings is not an array
		const kunyomi = Array.isArray(data?.readings)
			? data.readings.filter((r) => r.type === "kunyomi").map((r) => r.reading).filter(Boolean) // Filter out any falsy values
			: []; // Default to empty array if readings is not an array

		// Set info content
		infoChar.textContent = kanji;
		infoPrimary.textContent = primaryMeaning ? `Primary: ${primaryMeaning}` : "Primary: N/A";

		let typeLabel = infoType.querySelector(".kanji-type-label");
		if (!typeLabel) {
			typeLabel = document.createElement("span");
			typeLabel.className = "kanji-type-label";
			infoType.prepend(typeLabel);
		}
		typeLabel.textContent = type
			? `${type.toLowerCase().charAt(0).toUpperCase() + type.toLowerCase().slice(1)}`
			: "Passive";
		infoType.hidden = !primaryMeaning; // Hide type if no primary meaning
		infoType.classList.remove("type-active", "type-recognition"); // Remove all possible type classes
		infoType.classList.add(type ? `type-${type.toLowerCase()}` : ""); // Add class based on type for styling
		const helpTextMap = {
			"active": "You are expected to read and write this kanji.",
			"recognition": "You are expected to recognise this kanji, but not necessarily write it."
		};
		const helpText = helpTextMap[type?.toLowerCase()] || "You are not expected to actively know this kanji. It may be included for reference or future learning.";
		infoType.setAttribute("data-help", helpText);

		const tooltip = infoType.querySelector(".help-tooltip");
		if (tooltip) {
			tooltip.textContent = helpText;
		} else if (typeof window.initHelpTooltips === "function") {
			window.initHelpTooltips();
		}

		infoMeanings.textContent = meanings.length ? meanings.join(", ") : "No meanings listed.";
		infoOnyomi.textContent = onyomi.length ? onyomi.join(" ・ ") : "No on'yomi recorded.";
		infoKunyomi.textContent = kunyomi.length ? kunyomi.join(" ・ ") : "No kun'yomi recorded.";
	};

	/**
	 * Fetches kanji data from the server API.
	 */
	const fetchKanjiData = async (kanji) => {
		try {
			// Fetch kanji data from the server's API
			// Encode the kanji to ensure it's safe for use in a URL (just in case)
			const res = await fetch(`api/${encodeURIComponent(kanji)}`);
			if (!res.ok) { // Handle non-OK responses
				// Throw error to be caught below
				/* This allows us to handle fetch errors uniformly,
				   whether they are network errors or server errors. */
				throw new Error(`Failed to fetch kanji data: ${res.status}`);
			}
			return await res.json(); // Return the fetched kanji data
		} catch (error) { // Catch all errors
			console.error("Kanji fetch failed:", error); // Log any errors during fetch
			return { status: "loading" }; // Return loading status on error
		}
	};
	
	const PREFETCH_BATCH_SIZE = 12;
	const prefetchQueue = new Set();
	const blockByKanji = new Map();
	let prefetchTimer = null;
	let prefetchInFlight = false;

	const schedulePrefetch = () => {
		if (prefetchTimer) return;
		prefetchTimer = window.setTimeout(flushPrefetch, 120);
	};

	const flushPrefetch = async () => {
		if (prefetchInFlight) return;
		const batch = Array.from(prefetchQueue).slice(0, PREFETCH_BATCH_SIZE);
		if (!batch.length) {
			prefetchTimer = null;
			return;
		}

		batch.forEach((kanji) => prefetchQueue.delete(kanji));
		prefetchInFlight = true;
		prefetchTimer = null;

		try {
			const res = await fetch("api/batch", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({ kanji: batch })
			});

			if (!res.ok) {
				throw new Error(`Failed batch fetch: ${res.status}`);
			}

			const payload = await res.json();
			const dataMap = payload?.data || {};
			Object.entries(dataMap).forEach(([kanji, data]) => {
				const block = blockByKanji.get(kanji);
				const type = block?.dataset.category || null;
				kanjiCache.set(kanji, { data, type });
				if (block) block.dataset.loaded = "true";
			});
		} catch (error) {
			console.error("Kanji prefetch failed:", error);
		} finally {
			prefetchInFlight = false;
			if (prefetchQueue.size) schedulePrefetch();
		}
	};

	const queuePrefetch = (kanji) => {
		if (!kanji || kanjiCache.has(kanji)) return;
		prefetchQueue.add(kanji);
		schedulePrefetch();
	};

	blocks.forEach((block) => {
		block.tabIndex = 0; // Make each kanji block focusable for accessibility
		block.role = "button"; // Set role to button for screen readers to identify it as an interactive element
		const kanji = block.dataset.kanji || "";
		if (kanji) blockByKanji.set(kanji, block);
		// Add click event listener to each kanji block to handle selection and panel updates
		block.addEventListener("click", async () => {
			const kanji = block.dataset.kanji || "";
			setActive(block); // Set the clicked block as active
			openPanel(); // Open the information panel (if not already open)
			block.scrollIntoView({ // Smoothly scroll the selected block into view, centered in the viewport
				behavior: "smooth",
				block: "center",
				inline: "center"
			});

			if (!kanji) {
				setLoadingPanel(""); // Clear panel if kanji is invalid
				return;
			}

			const cached = kanjiCache.get(kanji); // Get cached data if available
			if (cached) {
				updatePanelFromData(kanji, cached); // Update panel from cached data
				return; // Exit early since data already available
			}

			setLoadingPanel(kanji); // Show loading state while fetching data
			const result = await fetchKanjiData(kanji);
			if (result.status === "ready" && result.data) {
				const type = block.dataset.category || null;
				kanjiCache.set(kanji, { data: result.data, type }); // Cache the fetched data
				block.dataset.loaded = "true"; // Mark the block as loaded
				updatePanelFromData(kanji, { data: result.data, type }); // Update the panel with the fetched data
			}
		});
		block.addEventListener("keydown", (event) => {
			if (event.key === "Enter" || event.key === " ") { // Allow selection with Enter or Space keys for accessibility
				event.preventDefault(); // Prevent default behavior (like scrolling)
				block.click(); // Trigger the click event to open the panel and load data
			}
		});
	});

	if (closeButton) {
		closeButton.addEventListener("click", () => {
			closePanel(); // Close the information panel when the close button is clicked
		});
	}

	// Prefetch nearby kanji only when they enter the viewport to reduce load.
	if ("IntersectionObserver" in window) {
		const prefetchObserver = new IntersectionObserver(
			(entries, entryObserver) => {
				entries.forEach((entry) => {
					if (entry.isIntersecting) {
						const kanji = entry.target.dataset.kanji || "";
						queuePrefetch(kanji);
						entryObserver.unobserve(entry.target);
					}
				});
			},
			{
				root: document.getElementById("kanji-list"),
				rootMargin: "200px",
				threshold: 0.1
			}
		);

		blocks.forEach((block) => prefetchObserver.observe(block));
	}

	document.addEventListener("keydown", (event) => {
		if (event.key === "Escape") {
			closePanel(); // Close the information panel when the Escape key is pressed
		}
	});

    // Intersection Observer to add "is-visible" class to kanji blocks as they enter the
    // viewport for animation effects. This implementation uses the Intersection Observer
    // API to efficiently detect when kanji blocks enter the viewport. When a block
    // becomes visible, it adds the "is-visible" class, which can trigger CSS animations
    // or transitions. The observer is configured with a root margin to start the animation
    // slightly before the block fully enters the view, creating a smoother user experience.
    // If the browser does not support Intersection Observer, all blocks are made visible
    // immediately as a fallback.
	if ("IntersectionObserver" in window) {
		const observer = new IntersectionObserver(
			(entries, entryObserver) => { // Loop through observed entries to check if they are intersecting (visible in the viewport)
				entries.forEach((entry) => {
					if (entry.isIntersecting) {
						entry.target.classList.add("is-visible"); // Add class to trigger visibility/animation
						entryObserver.unobserve(entry.target); // Stop observing this block since it's already visible.
					}
				});
			},
			{
				root: document.getElementById("kanji-list"), // Set the root to the scrollable container of the kanji blocks
				rootMargin: "60px", // Start the animation slightly before the block fully enters the view for a smoother effect
				threshold: 0.2 // Trigger when 20% of the block is visible in the viewport
			}
		);

		blocks.forEach((block) => observer.observe(block)); // Start observing each kanji block for visibility changes
	} else {
		blocks.forEach((block) => block.classList.add("is-visible")); // Fallback for browsers that do not support Intersection Observer: make all blocks visible immediately
	}
});
