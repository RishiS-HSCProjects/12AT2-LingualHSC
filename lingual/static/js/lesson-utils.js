class DirectoryPanel {
    constructor({
        containerId = 'directory-results',
        contentSelector = '.lesson-content',
        offset = 120 // Pixel offset for fixed headers
    } = {}) {
        this.container = document.getElementById(containerId);
        this.content = document.querySelector(contentSelector);
        this.offset = offset;
        this.headings = [];

        if (!this.container || !this.content) return; // Required elements not found. Should never happen.

        this.init();
    }

    init() {
        this.extractHeadings();
        if (!this.headings.length) return; // No headings found. Exit early.

        this.render();
        window.addEventListener('scroll', () => this.updateActive()); // Add scroll listener to update active heading
        this.updateActive();
    }

    extractHeadings() {
        const nodes = this.content.querySelectorAll('h1,h2,h3,h4,h5,h6');

        // Deconstruct heading nodes into objects holding id, text, level, and element reference
        // This object array will be used for rendering and scroll tracking
        // This setup was generated by OpenAI's ChatGPT.
        this.headings = [...nodes].map((h, i) => {
            h.id ||= `heading-${i}`;
            return {
                id: h.id,
                text: h.textContent.trim(),
                level: Number(h.tagName[1]),
                element: h
            };
        });
    }

    render() {
        // Create HTML
        this.container.innerHTML = this.headings.map(h => `
            <div class="directory-indent level-${h.level}" data-id="${h.id}">
                <a href="#${h.id}" class="directory-link">${h.text}</a>
            </div>
        `).join('');

        // Add click listeners
        this.container.querySelectorAll('.directory-link').forEach(link => {
            link.addEventListener('click', e => {
                e.preventDefault();
                const id = link.getAttribute('href').slice(1);
                const target = document.getElementById(id);
                if (!target) return;

                window.scrollTo({
                    top: target.offsetTop - this.offset,
                    behavior: 'smooth'
                });
            });
        });
    }

    updateActive() {
        const pos = window.scrollY + this.offset + 1;
        let active = null;

        for (const h of this.headings) {
            if (pos >= h.element.offsetTop) active = h.id;
        }

        this.container.querySelectorAll('.directory-indent').forEach(el => {
            el.classList.toggle('active', el.dataset.id === active);
        });
    }
}

class QuizRenderer {
    constructor({
        quizSelector = '.quiz',
        questionClass = 'quiz-question',
        optionClass = 'quiz-option',
        correctClass = 'quiz-correct',
        incorrectClass = 'quiz-incorrect',
        lockDelay = 500
    } = {}) {
        this.quizSelector = quizSelector;
        this.questionClass = questionClass;
        this.optionClass = optionClass;
        this.correctClass = correctClass;
        this.incorrectClass = incorrectClass;
        this.lockDelay = lockDelay;

        this.quizCache = {};

        this.init();
    }

    init() {
        document.querySelectorAll(this.quizSelector)
            .forEach(c => this.loadQuiz(c));
    }

    renderLoading(container) {
        // To make website load feel less janky, a loading state is shown.
        // This is good for UX as users will feel assured that something is happening,
        // instead of wondering if the site is broken.
        container.innerHTML = `
            <div class="quiz-loading">
                <div class="quiz-title">Loading Quiz</div>
                <div class="quiz-subtitle">Please waitâ€¦</div>
            </div>
        `;
    }

    // async definition allows for processes to run in the background without blocking the main thread.
    async loadQuiz(container) {
        const { lesson, id } = container.dataset;
        if (!lesson || !id) return; // Required data attributes not found. Should never happen.

        this.renderLoading(container);

        try {
            if (!this.quizCache[lesson]) {
                // Fetch quiz data for the lesson if not already cached
                const res = await fetch(`api/quiz/${lesson}`);

                if (!res.ok) {
                    let msg = "Unknown error";

                    try {
                        const err = await res.json(); // Attempt to parse error message from JSON
                        msg = err.error || msg; // Set msg to parsed error if available
                    } catch (_) {
                        // If JSON parsing fails, fallback to statusText
                        msg = res.statusText;
                    }

                    throw new Error("Network response was not ok: " + msg);
                }


                this.quizCache[lesson] = await res.json(); // Cache quiz data for the lesson
            }

            const quiz = this.quizCache[lesson][id];
            if (!quiz?.bank?.length) {
                throw new Error("Quiz data is invalid or empty");
            }

            this.startQuiz(container, quiz);
        } catch (e) {
            // Render error state if fetching or parsing fails
            container.innerHTML = `
                <div class="quiz-error">
                    <div class="quiz-title">Error Loading Quiz</div>
                </div>
            `;

            // Log error details to console for debugging
            console.error(`Failed to load quiz data for lesson "${lesson}", quiz ID "${id}".\n Error:`, e);
        }
    }

    startQuiz(container, quiz) {
        let questions = [...quiz.bank]; // Clone bank to avoid changing original data

        const limit = Number(container.dataset.limit); // Set question limit if specified
        const shuffle = container.dataset.shuffle !== undefined; // Enable shuffling if attribute is present

        if (shuffle) { // Shuffle question order if enabled using Fisher-Yates algorithm
            for (let i = questions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [questions[i], questions[j]] = [questions[j], questions[i]];
            }
        }

        if (!Number.isNaN(limit)) { // Limit number of questions if specified
            questions = questions.slice(0, limit);
        }

        this.renderQuestion(
            container, quiz, questions, 0, {
                correct: 0,
                total: questions.length,
                missed: []
            }, false
        );
    }

    /**
     * Renders a single question of the quiz.
     *
     * @param {HTMLElement} container - The container element where the question will be rendered.
     * @param {Object} quiz - The quiz object containing metadata and question bank.
     * @param {Array} questions - The array of questions to be presented in the quiz.
     * @param {number} index - The index of the current question to render.
     * @param {Object} score - The score object tracking correct answers and missed questions.
     * @param {boolean} isReview - Flag indicating if the quiz is in review mode for missed questions.
     */
    renderQuestion(container, quiz, questions, index, score, isReview) {
        /**
         * Normalises an answer string (supports various language scripts) for flexible matching.
         */
        const normaliseAnswer = (raw) => {
            if (raw == null) return "";

            let s = String(raw).normalize("NFKC").normalize("NFC");

            s = s.replace(/<[^>]*>/g, ""); // Remove HTML tags
            s = s.replace(/[\u200B-\u200F\uFEFF]/g, ""); // Remove zero-width and formatting chars
            s = s.replace(/[\x00-\x1F\x7F]/g, ""); // Remove control characters
            s = s.replace(/\u00A0/g, " "); // Replace non-breaking spaces with regular spaces
            s = s.replace(/\s+/g, " ").trim(); // Normalise whitespace
            s = s.replace(/[\p{P}\p{S}]/gu, ""); // Remove punctuation and symbols
            s = s.replace(/[-_]{2,}/g, "-"); // Replace multiple hyphens/underscores with single hyphen
            s = s.toLowerCase(); // Case insensitive matching

            return s;
        };

        const q = questions[index]; // Current question object
        if (!q) return;

        let bodyHTML = ""; // HTML for question body will be constructed here

        /* ---- Explanation and sample answer block construction ---- */
        const explanationParts = []; // Parts of the explanation block

        if (q.explanation) {
            // Add explanation block if provided
            explanationParts.push(`
            <div class="quiz-explanation-block">
                <strong>Explanation:</strong><br>
                ${q.explanation}
            </div>
        `);
        }

        if (q.sample_answer) {
            // Add sample answer block if provided
            explanationParts.push(`
            <div class="quiz-explanation-block">
                <strong>Sample answer:</strong><br>
                ${q.sample_answer}
            </div>
        `);
        }

        // Combine explanation parts into final HTML block
        const explanationHTML = explanationParts.length
            ? `<div class="quiz-explanation" hidden>${explanationParts.join("")}</div>` : "";
        /* ---------------------------------------------------------- */

        // Multiple choice rendering
        if (q.type === "mc") {
            const allowShuffle = q["allow-shuffle"] !== false;
            let shuffledOptions = q.options.map((text, originalIndex) => ({ text, originalIndex }));

            if (allowShuffle) {
                for (let i = shuffledOptions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledOptions[i], shuffledOptions[j]] = [shuffledOptions[j], shuffledOptions[i]];
                }
            }

            bodyHTML = `
            <ul class="quiz-options">
                ${shuffledOptions.map(opt => `
                    <li class="${this.optionClass}"
                        data-original-index="${opt.originalIndex}">
                        ${opt.text}
                    </li>
                `).join("")}
            </ul>
        `;
        }

        // Input rendering
        else if (q.type === "input") {
            bodyHTML = `
            <div class="quiz-input-container">
                <input type="text" class="quiz-input" autocomplete="off" />
                <button class="quiz-submit-btn" disabled>Submit</button>
            </div>
        `;
        }

        // Render block
        container.innerHTML = `
        <div class="quiz-title">
            ${quiz.title ?? "Quiz"}${isReview ? " (Review)" : ""}
        </div>
        <div class="${this.questionClass}">${q.question}</div>
        ${bodyHTML}
        ${explanationHTML}
        <div class="quiz-controls">
            <span class="quiz-progress">
                ${index + 1} / ${questions.length}
            </span>
            <button class="quiz-next-btn" disabled>
                ${index + 1 < questions.length ? "Next" : "Finish"}
            </button>
        </div>
    `;

        if (index !== 0 && q.type === "input") {
            setTimeout(() => container.querySelector(".quiz-input")?.focus(), 0);
        }

        const nextBtn = container.querySelector(".quiz-next-btn");
        let answered = false;
        let locked = true;
        setTimeout(() => locked = false, this.lockDelay);

        const markIncorrect = () => {
            if (!isReview) score.missed.push(q);
        };

        /* ---------- MC handling ---------- */
        if (q.type === "mc") {
            const options = container.querySelectorAll(`.${this.optionClass}`);
            options.forEach(opt => {
                opt.addEventListener("click", () => {
                    if (locked || answered) return;
                    answered = true;

                    const chosen = Number(opt.dataset.originalIndex);

                    options.forEach(o => {
                        o.style.pointerEvents = "none";
                        if (Number(o.dataset.originalIndex) === q.answer) {
                            o.classList.add(this.correctClass);
                        }
                    });

                    if (chosen === q.answer) {
                        if (!isReview) score.correct++;
                    } else {
                        opt.classList.add(this.incorrectClass);
                        markIncorrect();
                    }

                    const explanation = container.querySelector(".quiz-explanation");
                    if (explanation) explanation.hidden = false;

                    nextBtn.disabled = false;
                });
            });
        }

        /* ---------- input handling ---------- */
        else if (q.type === "input") {
            const input = container.querySelector(".quiz-input");
            const submit = container.querySelector(".quiz-submit-btn");
            const explanation = container.querySelector(".quiz-explanation");

            input.addEventListener("input", () => {
                submit.disabled = !input.value.trim();
            });

            const matchIncludes = (userNorm, includes) => {
                const missing = [];

                for (const group of includes) {
                    const groupArr = Array.isArray(group) ? group : [group];
                    const ok = groupArr.some(p => userNorm.includes(normaliseAnswer(p)));
                    if (!ok) missing.push(groupArr);
                }

                return { correct: missing.length === 0, missing };
            };

            submit.addEventListener("click", () => {
                if (locked || answered) return;
                answered = true;

                const userNorm = normaliseAnswer(input.value);
                let correct = false;
                let missingGroups = [];

                if (Array.isArray(q.includes) && q.includes.length) {
                    const res = matchIncludes(userNorm, q.includes);
                    correct = res.correct;
                    missingGroups = res.missing;
                } else if (Array.isArray(q.valid) && q.valid.length) {
                    // Checks that user answer matches one of the valid answers
                    correct = q.valid.some(v => normaliseAnswer(v) === userNorm);
                } else {
                    correct = true;
                }

                input.classList.add(correct ? this.correctClass : this.incorrectClass);
                input.disabled = true;
                submit.disabled = true;

                if (correct) {
                    if (!isReview) score.correct++;
                } else {
                    markIncorrect();

                    const answerBlock = document.createElement("div");
                    answerBlock.className = "quiz-valid-answers";
                    answerBlock.innerHTML = `
                    <div class="quiz-valid-label">Missing required elements:</div>
                    <ul class="quiz-valid-list">
                        ${missingGroups.map(g => `<li>${g.join(" / ")}</li>`).join("")}
                    </ul>
                `;
                    input.parentElement.appendChild(answerBlock);
                }

                if (explanation) explanation.hidden = false;
                nextBtn.disabled = false;
            });
        }

        /* ---------- navigation ---------- */
        nextBtn.addEventListener("click", () => {
            if (index + 1 < questions.length) {
                this.renderQuestion(container, quiz, questions, index + 1, score, isReview);
            } else if (!isReview && score.missed.length) {
                this.renderQuestion(container, quiz, score.missed, 0, score, true);
            } else {
                this.renderSummary(container, quiz, score);
            }
        });
    }

    renderSummary(container, quiz, score) {
        const percent = Math.round((score.correct / score.total) * 100);

        let header, subtitle;

        if (percent === 100) {
            header = "Perfect Score!";
            subtitle = "You're a natural!";
        } else if (percent >= 85) {
            header = "That's an A!";
            subtitle = "You have a strong understanding.";
        } else if (percent >= 70) {
            header = "Good Effort!";
            subtitle = "More practice recommended.";
        } else if (percent >= 50) {
            header = "Keep Trying!";
            subtitle = "Consider rereading the material.";
        } else {
            header = "Needs Improvement";
            subtitle = "Review the lesson and retry.";
        }

        container.innerHTML = `
            <div class="quiz-summary">
                <p class="quiz-header">${header}</p>
                <p class="quiz-subtitle">${subtitle}</p>
                <div class="quiz-score">
                    ${score.correct} / ${score.total} (${percent}%)
                </div>
                <button class="quiz-restart-btn">Retry Quiz</button>
            </div>
        `;

        container.querySelector('.quiz-restart-btn')
            .addEventListener('click', () => {
                this.startQuiz(container, quiz);
            });
    }
}

function scrollToAnchorWithOffset(id) {
    const target = document.getElementById(id);
    if (!target) return;

    const y = target.getBoundingClientRect().top + window.scrollY - 120; // Adjust for fixed header offset

    window.scrollTo({
        top: y,
        behavior: 'smooth'
    });
}

document.addEventListener('DOMContentLoaded', () => {
    // Initialize directory panel and quiz renderer on page load
    new DirectoryPanel();
    new QuizRenderer();

    if (window.location.hash) {
        const id = window.location.hash.slice(1); // Get ID from URL hash
        // Delay ensures content + headings are fully rendered
        setTimeout(() => {
            scrollToAnchorWithOffset(id);
        }, 0);
    }
});

document.addEventListener('click', (e) => {
    // Show spoiler content when spoiler elements are clicked
    const spoiler = e.target.closest('.spoiler');
    if (spoiler) {
        spoiler.classList.add('revealed');
        spoiler.removeAttribute('title');
    }
});

window.addEventListener('hashchange', () => {
    const id = window.location.hash.slice(1);
    if (!id) return;

    scrollToAnchorWithOffset(id);
});
