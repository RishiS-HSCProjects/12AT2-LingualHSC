class DirectoryPanel {
    constructor({
        containerId = 'directory-results',
        contentSelector = '.lesson-content',
        offset = 120 // Pixel offset for fixed headers
    } = {}) {
        this.container = document.getElementById(containerId);
        this.content = document.querySelector(contentSelector);
        this.offset = offset;
        this.headings = [];

        if (!this.container || !this.content) return; // Required elements not found. Should never happen.

        this.init();
    }

    init() {
        this.extractHeadings();
        if (!this.headings.length) return; // No headings found. Exit early.

        this.render();
        window.addEventListener('scroll', () => this.updateActive()); // Add scroll listener to update active heading
        this.updateActive();
    }

    extractHeadings() {
        const nodes = this.content.querySelectorAll('h1,h2,h3,h4,h5,h6');

        // Deconstruct heading nodes into objects holding id, text, level, and element reference
        // This object array will be used for rendering and scroll tracking
        // This setup was generated by OpenAI's ChatGPT.
        this.headings = [...nodes].map((h, i) => {
            h.id ||= `heading-${i}`;
            return {
                id: h.id,
                text: h.textContent.trim(),
                level: Number(h.tagName[1]),
                element: h
            };
        });
    }

    render() {
        // Create HTML
        this.container.innerHTML = this.headings.map(h => `
            <div class="directory-indent level-${h.level}" data-id="${h.id}">
                <a href="#${h.id}" class="directory-link">${h.text}</a>
            </div>
        `).join('');

        // Add click listeners
        this.container.querySelectorAll('.directory-link').forEach(link => {
            link.addEventListener('click', e => {
                e.preventDefault();
                const id = link.getAttribute('href').slice(1);
                const target = document.getElementById(id);
                if (!target) return;

                window.scrollTo({
                    top: target.offsetTop - this.offset,
                    behavior: 'smooth'
                });
            });
        });
    }

    updateActive() {
        const pos = window.scrollY + this.offset + 1;
        let active = null;

        for (const h of this.headings) {
            if (pos >= h.element.offsetTop) active = h.id;
        }

        this.container.querySelectorAll('.directory-indent').forEach(el => {
            el.classList.toggle('active', el.dataset.id === active);
        });
    }
}

class QuizRenderer {
    constructor({
        quizSelector = '.quiz',
        questionClass = 'quiz-question',
        optionClass = 'quiz-option',
        correctClass = 'quiz-correct',
        incorrectClass = 'quiz-incorrect',
        lockDelay = 500
    } = {}) {
        this.quizSelector = quizSelector;
        this.questionClass = questionClass;
        this.optionClass = optionClass;
        this.correctClass = correctClass;
        this.incorrectClass = incorrectClass;
        this.lockDelay = lockDelay;

        this.quizCache = {};

        this.init();
    }

    init() {
        document.querySelectorAll(this.quizSelector)
            .forEach(c => this.loadQuiz(c));
    }

    renderLoading(container) {
        // To make website load feel less janky, a loading state is shown.
        // This is good for UX as users will feel assured that something is happening,
        // instead of wondering if the site is broken.
        container.innerHTML = `
            <div class="quiz-loading">
                <div class="quiz-title">Loading Quiz</div>
                <div class="quiz-subtitle">Please waitâ€¦</div>
            </div>
        `;
    }

    // async definition allows for processes to run in the background without blocking the main thread.
    async loadQuiz(container) {
        const { lesson, id } = container.dataset;
        if (!lesson || !id) return; // Required data attributes not found. Should never happen.

        this.renderLoading(container);

        try {
            if (!this.quizCache[lesson]) {
                // Fetch quiz data for the lesson if not already cached
                const res = await fetch(`/nihongo/api/quiz/${lesson}`);

                if (!res.ok) {
                    let msg = "Unknown error";

                    try {
                        const err = await res.json(); // Attempt to parse error message from JSON
                        msg = err.error || msg; // Set msg to parsed error if available
                    } catch (_) {
                        // If JSON parsing fails, fallback to statusText
                        msg = res.statusText;
                    }

                    throw new Error("Network response was not ok: " + msg);
                }


                this.quizCache[lesson] = await res.json(); // Cache quiz data for the lesson
            }

            const quiz = this.quizCache[lesson][id];
            if (!quiz?.bank?.length) {
                throw new Error("Quiz data is invalid or empty");
            }

            this.startQuiz(container, quiz);
        } catch (e) {
            // Render error state if fetching or parsing fails
            container.innerHTML = `
                <div class="quiz-error">
                    <div class="quiz-title">Error Loading Quiz</div>
                </div>
            `;

            // Log error details to console for debugging
            console.error(`Failed to load quiz data for lesson "${lesson}", quiz ID "${id}".`);
            console.error(e);
        }
    }

    startQuiz(container, quiz) {
        let questions = [...quiz.bank]; // Clone bank to avoid changing original data

        const limit = Number(container.dataset.limit); // Set question limit if specified
        const shuffle = container.dataset.shuffle !== undefined; // Enable shuffling if attribute is present

        if (shuffle) { // Shuffle question order if enabled
            for (let i = questions.length - 1; i > 0; i--) {
                const j = Math.random() * (i + 1) | 0;
                [questions[i], questions[j]] = [questions[j], questions[i]];
            }
        }

        if (!Number.isNaN(limit)) { // Limit number of questions if specified
            questions = questions.slice(0, limit);
        }

        this.renderQuestion(
            container, quiz, questions, 0, {
                correct: 0,
                total: questions.length,
                missed: []
            }, false
        );
    }

    /**
     * Renders a single question of the quiz.
     *
     * @param {HTMLElement} container - The container element where the question will be rendered.
     * @param {Object} quiz - The quiz object containing metadata and question bank.
     * @param {Array} questions - The array of questions to be presented in the quiz.
     * @param {number} index - The index of the current question to render.
     * @param {Object} score - The score object tracking correct answers and missed questions.
     * @param {boolean} isReview - Flag indicating if the quiz is in review mode for missed questions.
     */
    renderQuestion(container, quiz, questions, index, score, isReview) {
        const q = questions[index]; // Current question to render
        if (!q) return; // No question found at the given index. Should never happen.

        let bodyHTML = '';

        if (q.type === 'mc') {
            let shuffledOptions = null;
            const allowShuffle = q['allow-shuffle'] !== false; // Default to true if not specified

            shuffledOptions = q.options.map((text, originalIndex) => ({
                text,
                originalIndex
            }));

            if (allowShuffle) {
                // Shuffle options if specified using Fisher-Yates algorithm
                for (let i = shuffledOptions.length - 1; i > 0; i--) {
                    const j = Math.random() * (i + 1) | 0;
                    [shuffledOptions[i], shuffledOptions[j]] =
                        [shuffledOptions[j], shuffledOptions[i]];
                }
            }

            // Generate HTML for multiple-choice options
            bodyHTML = `
                <ul class="quiz-options">
                    ${shuffledOptions.map((opt, i) => `
                        <li class="${this.optionClass}"
                            data-display-index="${i}"
                            data-original-index="${opt.originalIndex}">
                            ${opt.text}
                        </li>
                    `).join('')}
                </ul>
            `;
        } else if (q.type === 'input') {
            bodyHTML = `
                <div class="quiz-input-container">
                    <input type="text" class="quiz-input" autocomplete="off">
                    <button class="quiz-submit-btn" disabled>Submit</button>
                </div>
            `;
        }

        container.innerHTML = `
            <div class="quiz-title">
                ${quiz.title ?? 'Quiz'}
                ${isReview ? ' (Review)' : ''}
            </div>
            <div class="${this.questionClass}">${q.question}</div>
            ${bodyHTML}
            <div class="quiz-controls">
                <span class="quiz-progress">
                    ${index + 1} / ${questions.length}
                </span>
                <button class="quiz-next-btn" disabled>
                    ${index + 1 < questions.length ? 'Next' : 'Finish'}
                </button>
            </div>
        `;

        const nextBtn = container.querySelector('.quiz-next-btn');

        let answered = false; // Track if the question has been answered
        let locked = true; // Track if input is locked to prevent accidental submissions

        setTimeout(() => locked = false, this.lockDelay); // Only run the below logic after delay

        const markIncorrect = () => { // Anonymous function to handle incorrect answers
            if (!isReview) score.missed.push(q); // Add to missed questions if not in review mode
        };

        if (q.type === 'mc') {
            const options = container.querySelectorAll(`.${this.optionClass}`);

            options.forEach(opt => {
                opt.addEventListener('click', () => {
                    if (locked || answered) return; // Ignore clicks if locked or already answered
                    answered = true; // Mark question as answered

                    // Since options may be shuffled, we use originalIndex to check correctness
                    const chosenOriginalIndex = Number(opt.dataset.originalIndex);

                    // Disable all options and apply formatting for answers
                    options.forEach(o => {
                        o.style.pointerEvents = 'none';
                        const original = Number(o.dataset.originalIndex);
                        if (original === q.answer)
                            o.classList.add(this.correctClass); // Mark correct answer
                    });
                    if (chosenOriginalIndex === q.answer) {
                        if (!isReview) score.correct++; // Increment score if correct and not in review mode
                    } else {
                        opt.classList.add(this.incorrectClass); // Mark chosen option as incorrect
                        markIncorrect(); // Add to missed questions
                    }

                    nextBtn.disabled = false; // Enable the next button
                });
            });
        } else if (q.type === 'input') {
            const input = container.querySelector('.quiz-input');
            const submit = container.querySelector('.quiz-submit-btn');

            // Enable submit button only when there is input
            input.addEventListener('input', () => {
                submit.disabled = !input.value.trim();
            });

            // Handle submission of input answer
            submit.addEventListener('click', () => {
                if (locked || answered) return;
                answered = true;

                const val = input.value.trim();
                const correct = q.valid.includes(val); // Check if input matches any valid answers

                input.classList.add(correct ? this.correctClass : this.incorrectClass);
                input.disabled = true;
                submit.disabled = true;

                if (correct) {
                    if (!isReview) score.correct++;
                } else {
                    markIncorrect();
                    const answerBlock = document.createElement('div');
                    answerBlock.className = 'quiz-valid-answers';
                    answerBlock.innerHTML = `
                    <div class="quiz-valid-label">Accepted answers:</div>
                    <ul class="quiz-valid-list">
                        ${q.valid.map(v => `<li>${v}</li>`).join('')}
                    </ul>
                `;
                    input.parentElement.appendChild(answerBlock);
                }

                nextBtn.disabled = false;
            });
        }

        // Handle navigation to next question or summary
        nextBtn.addEventListener('click', () => {
            if (index + 1 < questions.length) {
                this.renderQuestion(container, quiz, questions, index + 1, score, isReview);
            } else if (!isReview && score.missed.length) {
                this.renderQuestion(container, quiz, score.missed, 0, score, true);
            } else {
                this.renderSummary(container, quiz, score);
            }
        });
    }

    renderSummary(container, quiz, score) {
        const percent = Math.round((score.correct / score.total) * 100);

        let header, subtitle;

        if (percent === 100) {
            header = "Perfect Score!";
            subtitle = "You're a natural!";
        } else if (percent >= 85) {
            header = "That's an A!";
            subtitle = "You have a strong understanding.";
        } else if (percent >= 70) {
            header = "Good Effort!";
            subtitle = "More practice recommended.";
        } else if (percent >= 50) {
            header = "Keep Trying!";
            subtitle = "Consider rereading the material.";
        } else {
            header = "Needs Improvement";
            subtitle = "Review the lesson and retry.";
        }

        container.innerHTML = `
            <div class="quiz-summary">
                <p class="quiz-header">${header}</p>
                <p class="quiz-subtitle">${subtitle}</p>
                <div class="quiz-score">
                    ${score.correct} / ${score.total} (${percent}%)
                </div>
                <button class="quiz-restart-btn">Retry Quiz</button>
            </div>
        `;

        container.querySelector('.quiz-restart-btn')
            .addEventListener('click', () => {
                this.startQuiz(container, quiz);
            });
    }
}

document.addEventListener('DOMContentLoaded', () => {
    // Initialize directory panel and quiz renderer on page load
    new DirectoryPanel();
    new QuizRenderer();
});
